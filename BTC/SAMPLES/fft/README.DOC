I originally saw an FFT program in Byte Magazine many years ago.  I wrote
a version for BASIC that worked pretty good.  Then I thought I'd translate
it into C.  These programs are the result.  I don't do windows though...

Needs a graphic interface, but the time escapes me.  Please upload any better
graphic versions.

The original Byte Magazine program was designed for real data only.  In my
experiments I needed to preserve both real and imaginary data.  If you feed
the FFT real data only, then the output will be a mirror image, and you can
ignore the left side.

For an example try:

	gen 16 in
	1000
	3000

Which will sample the 1 Khz data every 333 microseconds (1 / 3 Khz).
Note: The sample frequency should be greater than 2 times the input
frequency (Nyquist and all that...).

Then run fft.exe like so:

	fft 16 in out

And you should see a display like so:

0	|=======				      (-1500.0 Hz)
1	|=====					      (-1312.5 Hz)
2	|====					      (-1125.0 Hz)
3	|====					       (-937.0 Hz)
4	|===					       (-750.0 Hz)
5	|===					       (-562.5 Hz)
6	|===					       (-375.0 Hz)
7	|===					       (-187.5 Hz)
8	|====		<-------   DC			(000.0 Hz)
9	|====		<-------   Fundamental		(187.5 Hz)
10	|======		<-------   Second Harmonic	(375.0 Hz)
11	|========					(562.5 Hz)
12	|==============					(750.0 Hz)
13	|========================================================
14	|============================		    (1125.0 Hz)	^
15	|===========				    (1312.5 Hz)	|
								|
				[13 - 8 (center)] * 187.5 = 937.0 Hz

The fundamental display frequency is:

	T  = Time Increment Between Samples
	N  = Number Of Samples
	Tp = N * T

	Then F = 1 / Tp

	In the example above, the time increment between samples is
	1 / 3000 or 333 microseconds.  N = 16, so Tp = 5333 microseconds
	and 1 / .005333 is 187.5 Hz.

	Therefore each filter is a multiple of 187.5 Hertz.  Filter 8 in this
	example is center, so that would be zero, 9 would be one, etc.

In this case the sample interval didn't work so good for the frequency and
shows the limitation of the Discrete Fourier Transform in representing a
continuous signal.  A better sample rate for 1000 Hz would be 4000 Hz,
in which case T = 250 ms, Tp = 4 ms, and F = 250 Hz.  1000 / 250 = 4.  The
power should all be in filter 12 (8 + 4) in this case.

Let's run it and see:

	gen 16 in
	1000
	4000

	fft 16 in out

0	|
1	|
2	|
3	|
4	|
5	|
6	|
7	|
8	|
9	|
10	|
11	|
12	|========================================================
13	|
14	|
15	|

Well what do you know...

The output file data can be used by other programs as needed.

By using negative frequencies in gen.exe you can generate opening targets:

	gen 16 in
	-1000
	3000
	fft 16 in out

Produces:

0	|=======
1	|===========
2	|============================
3	|=======================================================
4	|==============
5	|========
6	|======
7	|====
8	|====		<-------- Zero Hertz (DC)
9	|===
10	|===
11	|===
12	|===
13	|====
14	|====
15	|=====

You can see in these examples where weighting functions would be nice.
For an example of what happens when the imaginary data is not input
(ie, zeros put in) for a 1000 Hz frequency at 3000 Hz sample rate:

0	|===============
1	|==================
2	|===================================
3	|========================================================
4	|===========
5	|====
6	|==
7	|=				Trash this part
---------------------------------------------------------------------
8	|
9	|=
10	|==
11	|====
12	|===========
13	|=======================================================
14	|===================================
15	|==================

The left side is redundant and can be deleted.  This is what the original
Byte Magazine article did (December 1978 Issue).

Good luck, have fun with it,
Steve Sampson, CompuServe: 75136,626  Unix: sampson@killer.dallas.tx.us
