






  PRODUCT  :  Borland C++                            NUMBER  :  730
  VERSION  :  2.0
       OS  :  DOS
     DATE  :  September 18, 1991                       PAGE  :  1/7

    TITLE  :  Example Source Code for TEMC Filter




  /*
       EXAMPLE SOURCE CODE FOR TEMC FILTER

       TEMC2MSG.C

       TEMC2Msg - output filter to Turbo C++ IDE message window
            This filter accepts input through the standard input
            stream, converts it and outputs it to the standard
            output stream.  The streams are linked through pipes,
            such that the input stream is the output from the
            assembler being invoked, and the output stream is
            connected to the message window of the Turbo C++ IDE,
            ie. temc fname configname | temc2msg | Turbo C++
            message window

       Compile using Turbo C++ in the LARGE memory model
            tcc -ml temc2msg
  */

  #include <dir.h>
  #include <dos.h>
  #include <stdlib.h>
  #include <fcntl.h>
  #include <string.h>
  #include <alloc.h>
  #include <io.h>
  #include <ctype.h>
  #include "filter.h"

  #define TRUE (1 == 1)
  #define FALSE !(TRUE)

  /* Turbo TEMC text for conversion */
  char TemcWarningTxt[] = "Warning ";
  char TemcErrorTxt[]   = "Error ";
  char TemcFatalTxt[]   = "Fatal ";

  char     CurFile[MAXPATH];       /* Current file in message
  window */
  unsigned BufSize,                /* Size of internal working
  buffer */
           CurBufLen;              /* Buffer space in use */
  char     *InBuffer,              /* Input buffer */













  PRODUCT  :  Borland C++                            NUMBER  :  730
  VERSION  :  2.0
       OS  :  DOS
     DATE  :  September 18, 1991                       PAGE  :  2/7

    TITLE  :  Example Source Code for TEMC Filter




           *OutBuffer,             /* Output buffer */
           *CurInPtr,              /* current character in input
                                      buffer */
           *CurOutPtr,             /* current character in output*/
           *LinePtr;               /* pointer to the current
                                      character in the input
                                      buffer*/
  int      (*processor)(char *);   /* function pointer used to call
                                      the appropriate conversion
                                      routine */
  char     Line[133];              /* static buffer to store line
                                      most recently input */
  long int InOff;                  /* position in actual input
                                      stream */
  char     EndMark;                /* Used to output end of data to
  message
                                      window */

  /*************************************************************************
  Function  : NextChar
  Parameters: none
  Returns   : next character in input buffer or 0 on end of file

  Input from the standard input stream is buffered in a global
  buffer InBuffer which is allocated in function main.  The
  function will return the next character in the buffer, reading
  from the input stream when the buffer becomes empty.
  **********************************************************************/
  char NextChar(void)
  {
    if (CurInPtr < InBuffer+CurBufLen)  /* if buffer is not empty*/
    {
      return *(CurInPtr++);             /* return next character */
    }
    else
    {
      CurInPtr = InBuffer;              /* reset pointer to front
                                           of buffer */
      lseek(0,InOff,0);                 /* seek to the next section
                                           for read */
      InOff += BufSize;                 /* increment pointer to
                                           next block */
      if ((CurBufLen = read(0,InBuffer,BufSize)) !=0)













  PRODUCT  :  Borland C++                            NUMBER  :  730
  VERSION  :  2.0
       OS  :  DOS
     DATE  :  September 18, 1991                       PAGE  :  3/7

    TITLE  :  Example Source Code for TEMC Filter




        return NextChar();              /* recursive call merely
                                           returns first character
                                           in buffer after read */
      return 0;                         /* return 0 on end of
                                           file*/
    }
  }

  /*************************************************************************
  Function  : flushOut
  Parameter : Size   The number of characters to be written out
  Returns   : nothing

  Strings to be sent to the message window are buffered in a buffer
  called OutBuffer.  A call to this function will write out Size
  bytes from OutBuffer to the standard output stream and resets the
  output buffer pointer to the beginning of the buffer.  The output
  buffer is considered empty after a call to this function.
  ***********************************************************************/
  void flushOut(unsigned Size)
  {
     if (Size != 0)                /* don't flush an empty buffer*/
     {
        CurOutPtr = OutBuffer;     /* reset pointer to beginning of
                                      buffer */
        lseek(1,0,2);              /* seek output stream to end */
        write(1,OutBuffer,Size);   /* write out Size bytes */
     }
  }

  /************************************************************************
  Function  : Put
  Parameters: S    pointer to bytes being put into output buffer
              Len  number of bytes to be put in output buffer
  Returns   : nothing

  Put places bytes into OutBuffer so they may be later flushed out
  into the standard output stream.
  ***********************************************************************/
  void Put(char *S,int Len)
  {
     int i;














  PRODUCT  :  Borland C++                            NUMBER  :  730
  VERSION  :  2.0
       OS  :  DOS
     DATE  :  September 18, 1991                       PAGE  :  4/7

    TITLE  :  Example Source Code for TEMC Filter




     for (i = 0; i < Len; i++)
     {
        *CurOutPtr++ = S[i];             /* place byte in buffer */
        if (CurOutPtr >= OutBuffer+BufSize)/* if buffer overflows*/
           flushOut(BufSize);               /* flush the buffer */
     }
  }

  /*************************************************************************
  Function  : ProcessLine
  Parameters: Line  a pointer to the current line of characters to
                    process
  Returns   : 1 if line is a Turbo Assembler line
              0 if line is not

  Process through a line of input to determine if it is a Turbo
  Assembler output line and convert it to information for the Turbo
  C++ message window.

  Turbo Assembler lines which are in need of conversion are of the
  form:

      message-type source-file(LINE #) message-text

  where type is one of: Warning, Error

  TASM lines are identified by the first portion of text.  If
  warning, error or fatal is determined at the outset, text is
  output from there as it is scanned.  Any incorrect configuration
  will simply abort the scanning of the rest of the line.
  **********************************************************************/
  int ProcessLine(char *Line)
  {
     char     Type;
     unsigned i;
     char     *s;
       char     fn[MAXPATH];

     /* don't try to process a NULL line */
     if (Line[0] == 0)
        return 0;

     /* check for temc type tags */













  PRODUCT  :  Borland C++                            NUMBER  :  730
  VERSION  :  2.0
       OS  :  DOS
     DATE  :  September 18, 1991                       PAGE  :  5/7

    TITLE  :  Example Source Code for TEMC Filter




     if (strncmp(Line,TemcWarningTxt,strlen(TemcWarningTxt))== 0)
        memmove(Line,&Line[strlen(TemcWarningTxt)],strlen(Line));
     else if (strncmp(Line,TemcErrorTxt,strlen(TemcErrorTxt))== 0)
        memmove(Line,&Line[strlen(TemcErrorTxt)],strlen(Line));
     else if (strncmp(Line,TemcFatalTxt,strlen(TemcFatalTxt))== 0)
        memmove(Line,&Line[strlen(TemcFatalTxt)],strlen(Line));
     else return 1;             /* geen TEMC line */

      s = strchr(Line,':');        /* find : */
      if (s != NULL)               /* if no :, invalid line */
          {
          while (*s != ' ')
            s--;
          memmove(fn,Line,(unsigned)(s-Line)); /*save filename*/
          fn[(unsigned)(s-Line)] = 0;  /* null terminate name */
          memmove(Line,++s,strlen(Line));  /* shift line left */
          if (strcmp(fn,CurFile) != 0)   /* if new filename */
               {
               Type = MsgNewFile; /* indicate by sending type
                                     out to message window */
            strcpy(CurFile,fn);
            Put(&Type,1);
            Put(CurFile,strlen(CurFile)+1);                 /*
  along with the new name */
            }
             Type = MsgNewLine;   /* set type to new line */
          s = strchr(Line,':');     /* find : */
          *s = 0;           /* isolate number in string */
          i = atoi(Line); /* if number is found convert string
                                to integer */
             if (i != 0)
            {
            Put(&Type,1);    /* indicate need for new line */
            Put((char *)&i,2);     /* put the number out */
            i = 1;           /* set column in message box */
            Put((char *)&i,2);  /* tab over to put message */
            s++;
            memmove(Line,s,strlen(s)+1);    /* shift line */
            while (Line[0] == ' ' && Line[0] != 0)  /* strip
                                               spaces from line */
                memmove(Line,&Line[1],strlen(Line));
            Put(Line,strlen(Line)+1); /*output the message */
            return 0;              /* OK Temc line */













  PRODUCT  :  Borland C++                            NUMBER  :  730
  VERSION  :  2.0
       OS  :  DOS
     DATE  :  September 18, 1991                       PAGE  :  6/7

    TITLE  :  Example Source Code for TEMC Filter




            }
           return 1;   /* invalid line number, not TASM line */
           }
           else        /* Fatal error, no line # or filename */
            {
            Type = MsgNewLine; /* Fake line #  etc.*/
            i = 1;
            Put(&Type,1);
            Put((char *)&i,2);
            Put((char *)&i,2);
            while (Line[0] == ' ' && Line[0] != 0)
                 memmove(Line,&Line[1],strlen(Line));
            Put(Line,strlen(Line)+1);
            return 0;
            }
  }

  /***********************************************************************
  Function  : main

  Returns   : zero for successful execution
              3    if an error is encountered

  The main routine allocates buffers for the input and output
  buffer.  Characters are then read from the input buffer building
  the line buffer that will be sent to the filter processor.  Lines
  are read and filtered until the end of input is reached.
  ***********************************************************************/
  int main( void )
  {
     char c;
     unsigned long core;

     setmode(1,O_BINARY);    /* set output stream to binary mode */
     core = farcoreleft();
     if (core > 64000U)
        BufSize = 64000U;
     else BufSize = (unsigned)core;     /* get available memory */
                                        /* stay under 64K */
     if ((CurInPtr = malloc(BufSize)) == NULL) /* allocate buffer
                                                  space */
        exit(3);














  PRODUCT  :  Borland C++                            NUMBER  :  730
  VERSION  :  2.0
       OS  :  DOS
     DATE  :  September 18, 1991                       PAGE  :  7/7

    TITLE  :  Example Source Code for TEMC Filter




     processor = NULL;                  /* set current processor to
                                           none */
     InBuffer = CurInPtr;               /* input buffer is first
                                           half of space */
     BufSize = BufSize/2;               /* output buffer is 2nd
                                           half */
     OutBuffer = InBuffer + BufSize;
     CurOutPtr = OutBuffer;             /* set buffer pointers */
     LinePtr = Line;
     CurBufLen = 0;
     Put(PipeId,PipeIdLen);             /* send ID string to
                                           message window */
     while ((c = NextChar()) != 0)      /* read characters */
     {
        if ((c == 13) || (c == 10))     /* build until line end */
        {
           *LinePtr = 0;
           ProcessLine(Line);           /* filter the line */
           LinePtr = Line;
        }
      /* characters are added to buffer up to 132 characters max */
        else if ((FP_OFF(LinePtr) - FP_OFF(&Line)) < 132)
        {
           *LinePtr = c;                /* add to line buffer */
           LinePtr++;
        }
     }
     *LinePtr = 0;
     ProcessLine(Line);                 /* filter last line */
     EndMark = MsgEoFile;
     Put(&EndMark,1);                   /* indicate end of input to
                                           the message window */
     flushOut((unsigned)(CurOutPtr-OutBuffer)); /*flush the
                                                  buffer*/
     return 0;                          /* return OK */
  }













