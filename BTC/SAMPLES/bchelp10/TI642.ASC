






  PRODUCT  :  Borland C++                            NUMBER  :  642
  VERSION  :  2.0
       OS  :  PC DOS
     DATE  :  September 11, 1991                       PAGE  :  1/2

    TITLE  :  "Duplicate Symbol" Error on 'extern'ed Variable(s)




  All variables declared globally without the static  storage class
  modifier become public symbols.   So  the  linker  will encounter
  them when processing that  obj  file.  Another module will not be
  able to refer to  them,  because  the  compiler will not generate
  code  that  references  them unless it has type information.  One
  gives  this type information to the  compiler  by  declaring  the
  variables as externs within that module.   Then the  compiler can
  generate proper code and let the linker fix up references  to the
  variable.

  NOTE, however, that whenever you initialize  a  variable, whether
  extern or not, the compiler  must create storage for the variable
  within that module, even  with  externs.  Why?  The compiler does
  not have access  to  the  module  in which the extern variable is
  actually stored.  If it were to modify the value of  that storage
  location, it would mean passing a message on to the linker  to do
  so, and there really  is  no mechanism for doing that through the
  intel/hex  format  for  object  modules  unless  you   wanted  to
  introduce some nonstandard record within the obj files.    So the
  compiler creates storage for the variable within that module.

  For example,

                           extern int a = 0;

  has the same affect as

                              int a = 0;

  A common situation in which this occurs involves global variables
  such as _stklen, which specifies the  size  of the stack.  If one
  uses _stklen to  set the size of the stack like this:

                    extern unsigned _stklen = 8192;

  a "duplicate symbol" warning will be returned  from  the compiler
  for the reason discussed above.

  Breaking a  program into several modules, possibly to overcome an
  "Out  of  memory"  compiler error, is another  common  source  of
  "duplicate symbol" warnings.  This  occurs because one or more of
  the existing symbols were  both  declared  and initialized at the
  same time:













  PRODUCT  :  Borland C++                            NUMBER  :  642
  VERSION  :  2.0
       OS  :  PC DOS
     DATE  :  September 11, 1991                       PAGE  :  2/2

    TITLE  :  "Duplicate Symbol" Error on 'extern'ed Variable(s)




                           int avariable = 1;

  After  breaking  up  the  program,  this  declaration   is  moved
  wholesale into a header file and prefixed with the extern keyword
  in an attempt to provide that this variable can  be  seen  across
  modules.    Subsequent  attempts  to  compile  the  project will,
  however, result in  "duplicate  symbol" warnings.  To correct the
  problem, remove the initialization so that the line in the header
  file appears as:

                           int avariable;

  and initialize avariable in the source file where it is declared.




































