






  PRODUCT  :  C++                                    NUMBER  :  638
  VERSION  :  All
       OS  :  PC DOS
     DATE  :  September 17, 1991                       PAGE  :  1/2

    TITLE  :  Calling Operators from Member Functions




  The following provides examples  of  different  ways to invoke an
  operator,  how  to  call  such  operators  from  within a  member
  function and deals with some related multiple inheritance issues.

  You can always invoke an operator by name. For example, given:

                 X_Class {
                 ...
                   public:
                     X_Class &operator +( X_Class y);
                 };

                 X_Class  x, y;

  the function for the + operator can be invoked in several ways:

                 x + y;
                 x.operator +(y);

  We  can think of the second example in this way: not only have we
  overloaded  the  +  operator  to  add together instances  of  the
  X_Class, we also created a member function of  the  X_Class whose
  name is operator +.

  If X_Class has a member function foo, and we want  to  call the +
  operator from  within  it,  we  would  do  it by using its member
  function name:

                 X_Class::foo(X_Class &y) {
                   ...
                   operator +(y);
                   ...
                 }

  If one is dealing with multiple inheritance, and  operator  + has
  been redefined in several different  classes,  one  might  get an
  ambiguity at some point.  To resolve this, or any other ambiguity
  the  compiler  faces  when  it  cannot  determine  which  of  the
  overloaded  functions  it  must  use,  you can qualify  a  member
  function name with its class name.  For example suppose we have:
















  PRODUCT  :  C++                                    NUMBER  :  638
  VERSION  :  All
       OS  :  PC DOS
     DATE  :  September 17, 1991                       PAGE  :  2/2

    TITLE  :  Calling Operators from Member Functions




                           A     B
                            \   /
                              C

  and there is a public A & operator +( int )  defined  for  both A
  and B, and both  A and B are inherited publicly into C. Then

                           A ans;
                           C c1;

                           ans = c1 + 4;

  will be ambiguous.  It can be resolved by going,

                      ans = c1.B::operator +(4); or

                      ans = c1.A::operator +(4);

  depending  on which one you wanted to use.  This is because :: is
  the  scope  operator.   It is used to specify which scope a given
  symbol comes from.




























