






  PRODUCT  :  Borland C++                            NUMBER  :  706
  VERSION  :  2.0
       OS  :  DOS
     DATE  :  September 18, 1991                       PAGE  :  1/2

    TITLE  :  Fix for BCWDEMO Line Drawing Example




  BCWDEMO does not draw lines appropriately if drawn from lower
  right to upper left. The below replacement code fixes the
  problem.

  Basically, the code ordering must be changed and a new
  conditional statement substituted for the old. Below code --
  replacement function -- fixes the line drawing problem.

  /****************************************************************
   * function DoLButtonUp
   *    When the left mouse button is released, this routine
   *    allows other windows to receive mouse messages and saves
   *    the position of the mouse as the other corner of a bounding
   *    rectangle for the shape.
   ***************************************************************/

  void DoLButtonUp(HWND hWnd, LONG lParam)
  {
      ReleaseCapture();

      /*
       * if the origin of the line has changed, it should be drawn
       * from upper right to lower left and therefore has negative
       * slope.  Otherwise it will have positive slope.
       */

      if (CurrentShape == LINE)
        thisShape[CurrentPoint].Slope =
        (thisShape[CurrentPoint].Points.left < LOWORD(lParam) &&
         thisShape[CurrentPoint].Points.top < HIWORD(lParam)) ||
        (thisShape[CurrentPoint].Points.left > LOWORD(lParam) &&
         thisShape[CurrentPoint].Points.top > HIWORD(lParam))
         ? 1 : -1;























  PRODUCT  :  Borland C++                            NUMBER  :  706
  VERSION  :  2.0
       OS  :  DOS
     DATE  :  September 18, 1991                       PAGE  :  2/2

    TITLE  :  Fix for BCWDEMO Line Drawing Example




      /*
       * For rectangles to work with the IntersectRect function,
       * they must be stored as left, top, right, bottom.
       */
      SetRect(&thisShape[CurrentPoint].Points,
              min(thisShape[CurrentPoint].Points.left,
              LOWORD(lParam)),
              min(thisShape[CurrentPoint].Points.top,
              HIWORD(lParam)),
              max(thisShape[CurrentPoint].Points.left,
              LOWORD(lParam)),
              max(thisShape[CurrentPoint].Points.top,
                 HIWORD(lParam)));
      /*
       * Mark this region on the window as
       * needing redrawing and force an update.
       */
      InvalidateRect(hWnd, &thisShape[CurrentPoint].Points, 0);
      UpdateWindow(hWnd);
      mouseDown = 0;
      oldx = -1;
      oldy = -1;
  }


























